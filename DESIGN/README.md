## Things to consider while designing a system:
- Features
- API
- Availability
- Latency
- Scalability
- Durability
- Class Diagram
- Security and Privacy
- Cost-effective

## General concepts:
- Vertical vs Horizontal scaling
- CAP theorem: can only achieve only two things:
     - *consistency (Every read receives the most recent write or an error)*
     - *availablity (Every request receives a (non-error) response, without the guarantee that it contains the most recent write)*
     - *partition tolerance (The system continues to operate despite an arbitrary number of messages being dropped (or delayed) by the network between nodes)*
     - When a network partition failure happens, it must be decided whether to cancel the operation and thus decrease the availability but ensure consistency or to proceed with the operation and thus provide availability but risk inconsistency.
- [ACID vs BASE](https://phoenixnap.com/kb/acid-vs-base):
    - used with SQL (Ex. Transactions) vs used with NOSQL (Ex. Social media feeds)
    - The CAP theorem states that it is impossible to achieve both consistency and availability in a partition tolerant distributed system (i.e., a system which continues to work in cases of temporary communication breakdowns)
    - The fundamental difference between ACID and BASE database models is the way they deal with this limitation. The ACID model provides a consistent system. The BASE model provides high availability
- [Partioning/Sharding data](https://www.quora.com/Whats-the-difference-between-sharding-DB-tables-and-partitioning-them): 
    - *consistent hashing*
    - Data is distributed across multiple servers using partitioning, and each partition is further replicated to provide availability. The technique for distributing (aka partitioning) is *consistent hashing*.
    - Sharding is a method to distribute data across multiple different servers. We achieve horizontal scalability through sharding. It is a type of partitioning, such as Horizontal Partitioning (HP). "Horizontal partitioning", or sharding, is replicating [copying] the schema, and then dividing the data based on a shard key.
- [Optimistic vs Pessimistic Locking](https://stackoverflow.com/questions/129329/optimistic-vs-pessimistic-locking)
- SQL DB vs NoSQL 
- Types of NoSQL (*Key value, wide column, document based, graph based*)
- Caching (*unsplit cache, splitted cache*):
    - Every node does its own cachening and cached data is not shared between nodes (*unsplit*).
    - Cached data is shared between different nodes (*splitted cache*).
    - Cached data is stored in memory so it has to be small and is not the source of truth.
- Data center/Racks/Hosts
- CPU/Memory/Harddrive/Network bandwidth: 
    - These are all limit resources and you need to decide how you work around these limitations when designing a system. How you improve throughput, latency and scale your system around these limitations.
- Random vs Sequential r/w on disk:
    - Random is slower and sequential r/w are faster. You should design your system on sequential r/w.

## Internal concepts:
- HTTP vs http2 vs WebSocket
- TCP/IP model
- ipv4 vs ipv6
- TCP vs UDP
- DNS lookup
- Http & TLS
- Public key infrastructure and certificate authority(CA)
- Symmetric vs asymmetric encryption
- Load Balancer
- CDNs & Edges
- Bloom filters and Count-Min sketch
- Paxos 
- Leader election
- Design patterns and Object-oriented design
- Virtual machines and containers
- Pub-sub architecture 
- MapReduce
- Multithreading, locks, synchronization, CAS(compare and set)

### Tools:
- Cassandra
- MongoDB/Couchbase
- Mysql
- Memcached
- Redis
- Zookeeper
- Kafka
- NGINX
- HAProxy
- Solr, Elastic search
- Amazon S3
- Docker, Kubernetes, Mesos
- Hadoop/Spark and HDFS